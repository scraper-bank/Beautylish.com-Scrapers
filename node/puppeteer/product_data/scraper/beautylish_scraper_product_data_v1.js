/**
 * Generated by: ScrapeOps AI Scraper Generator on 2026-02-16
 * Signup For Free Beta: https://scrapeops.io/app/register/ai-scraper-generator
 * Docs & Updates: https://scrapeops.io/docs/ai-scraper-generator
 * For Support & Feedback Email: ai-scraper-generator@scrapeops.io
 */

const puppeteer = require('puppeteer-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
const cheerio = require('cheerio');
const fs = require('fs');
const { promisify } = require('util');

// Add stealth plugin
puppeteer.use(StealthPlugin());

const API_KEY = 'YOUR-API_KEY';

/**
 * Generate output filename with current timestamp
 * @returns {string} Output filename
 */
function generateOutputFilename() {
    const now = new Date();
    const timestamp = now.getFullYear().toString() +
        (now.getMonth() + 1).toString().padStart(2, '0') +
        now.getDate().toString().padStart(2, '0') + '_' +
        now.getHours().toString().padStart(2, '0') +
        now.getMinutes().toString().padStart(2, '0') +
        now.getSeconds().toString().padStart(2, '0');
    return 'beautylish_com_product_page_scraper_data_' + timestamp + '.jsonl';
}

// ScrapeOps Residential Proxy Configuration
const PROXY_SERVER = 'residential-proxy.scrapeops.io';
const PROXY_PORT = '8181';
const PROXY_USERNAME = 'scrapeops';
const PROXY_PASSWORD = API_KEY;

// Configuration
const CONFIG = {
    maxRetries: 3,
    maxConcurrency: 1,
    timeout: 180000,
    outputFile: generateOutputFilename()
};

/**
 * Data pipeline for handling scraped data
 */
class DataPipeline {
    constructor(outputFile = CONFIG.outputFile) {
        this.itemsSeen = new Set();
        this.outputFile = outputFile;
        this.writeFile = promisify(fs.appendFile);
    }

    isDuplicate(data) {
        const itemKey = JSON.stringify(data);
        if (this.itemsSeen.has(itemKey)) {
            console.warn('Duplicate item found, skipping');
            return true;
        }
        this.itemsSeen.add(itemKey);
        return false;
    }

    async addData(scrapedData) {
        if (!this.isDuplicate(scrapedData)) {
            try {
                const jsonLine = JSON.stringify(scrapedData) + '\n';
                await this.writeFile(this.outputFile, jsonLine, 'utf8');
                console.log('Saved item to', this.outputFile);
            } catch (error) {
                console.error('Error saving data:', error);
            }
        }
    }
}

/**
 * Extract structured data from HTML using Cheerio
 * @param {Object} $ - Cheerio instance
 * @param {string} url - Source URL
 * @returns {Object|null} - Extracted data or null
 */
function extractData($, url) {
    try {
        const makeAbsoluteURL = (urlStr) => {
            if (!urlStr) return "";
            urlStr = urlStr.trim();
            if (urlStr.startsWith("http://") || urlStr.startsWith("https://")) return urlStr;
            if (urlStr.startsWith("//")) return "https:" + urlStr;
            const domain = "https://www.beautylish.com";
            if (urlStr.startsWith("/")) return domain + urlStr;
            return domain + "/" + urlStr;
        };

        const detectCurrency = (priceText) => {
            priceText = priceText.toUpperCase();
            const currencyMap = {
                "USD": "USD", "US$": "USD", "US $": "USD", "$": "USD",
                "EUR": "EUR", "€": "EUR",
                "GBP": "GBP", "£": "GBP", "GB£": "GBP",
                "JPY": "JPY", "¥": "JPY", "JP¥": "JPY",
                "CAD": "CAD", "CA$": "CAD", "C$": "CAD",
                "AUD": "AUD", "AU$": "AUD", "A$": "AUD",
                "CNY": "CNY", "CN¥": "CNY", "RMB": "CNY",
                "CHF": "CHF", "FR.": "CHF",
                "SEK": "SEK", "KR": "SEK",
                "NZD": "NZD", "NZ$": "NZD",
            };
            for (const [code, currency] of Object.entries(currencyMap)) {
                if (priceText.includes(code)) return currency;
            }
            return "USD";
        };

        let jsonData = null;
        $('script[type="application/ld+json"]').each((i, el) => {
            try {
                const data = JSON.parse($(el).text());
                const objects = Array.isArray(data) ? data : [data];
                for (const obj of objects) {
                    if (obj['@type'] && obj['@type'].toLowerCase() === 'product') {
                        jsonData = obj;
                        return false; 
                    }
                }
            } catch (e) {}
        });

        const outputData = {};

        // Aggregate Rating
        let aggregateRating = null;
        if (jsonData && jsonData.aggregateRating) {
            aggregateRating = {
                bestRating: jsonData.aggregateRating.bestRating,
                ratingValue: jsonData.aggregateRating.ratingValue,
                reviewCount: jsonData.aggregateRating.reviewCount,
                worstRating: jsonData.aggregateRating.worstRating
            };
        }
        outputData.aggregateRating = aggregateRating;

        // Availability
        let availability = "";
        if (jsonData && jsonData.offers) {
            const avail = jsonData.offers.availability || "";
            if (avail.toLowerCase().includes("instock")) {
                availability = "in_stock";
            } else if (avail.toLowerCase().includes("outofstock")) {
                availability = "out_of_stock";
            }
        }
        if (!availability) {
            const availText = $('link[itemprop="availability"]').attr('href') || "";
            if (availText.includes("InStock")) availability = "in_stock";
        }
        outputData.availability = availability;

        // Brand
        let brand = "";
        if (jsonData && jsonData.brand) {
            brand = jsonData.brand.name || "";
        }
        if (!brand) {
            brand = $(".brand-name a").first().text().trim();
        }
        outputData.brand = brand;

        outputData.category = null;

        // Currency
        let currency = "USD";
        if (jsonData && jsonData.offers) {
            currency = jsonData.offers.priceCurrency || "";
        }
        if (!currency) {
            currency = detectCurrency($(".product-offer .price").text());
        }
        outputData.currency = currency;

        // Description
        let description = "";
        if (jsonData && jsonData.description) {
            description = jsonData.description;
        }
        if (!description) {
            description = $(".product-description").html() || "";
            description = description.trim();
        }
        outputData.description = description;

        // Features
        let features = [];
        $(".product-description h5").each((i, el) => {
            const title = $(el).text().toLowerCase();
            if (title.includes("special") || title.includes("ingredient") || title.includes("key")) {
                $(el).nextAll('ul').first().find('li').each((j, li) => {
                    const text = $(li).text().trim();
                    if (text) features.push(text);
                });
            }
        });

        if (features.length === 0 && jsonData && jsonData.description) {
            if (jsonData.description.includes("<li>")) {
                const $temp = cheerio.load(jsonData.description);
                $temp("li").each((i, li) => {
                    const text = $temp(li).text().trim();
                    if (text && !text.toLowerCase().startsWith("size:")) {
                        features.push(text);
                    }
                });
            }
        }
        outputData.features = features;

        // Images
        let extractedImages = [];
        const seenURLs = new Set();

        $("[data-section='product-carousel'] img, .product-media img").each((i, el) => {
            const src = $(el).attr('src');
            const alt = $(el).attr('alt') || "";
            if (!src) return;
            const fullURL = makeAbsoluteURL(src);
            if (!seenURLs.has(fullURL) && !fullURL.includes("afterpay") && !fullURL.includes("sezzle")) {
                extractedImages.push({ URL: fullURL, Alt: alt.trim() });
                seenURLs.add(fullURL);
            }
        });

        if (extractedImages.length === 0 && jsonData) {
            const img = jsonData.image;
            if (img) {
                const fullURL = makeAbsoluteURL(img);
                if (!seenURLs.has(fullURL)) {
                    extractedImages.push({ URL: fullURL, Alt: jsonData.name || "" });
                    seenURLs.add(fullURL);
                }
            }
        }

        const reSize = /(?i)(_\d+x\d+|p_\d+x\d+|ts|p_85x85|zb_p|orig|_AC_SL1500_)/i;
        const orderedGroups = [];
        const baseToIndex = {};

        extractedImages.forEach(img => {
            const base = img.URL.replace(reSize, "");
            let score = 0;
            if (img.URL.includes("zb_p") || img.URL.includes("orig") || img.URL.includes("zoom")) {
                score = 100;
            } else if (img.URL.includes("p_85x85") || img.URL.includes("p_35x35")) {
                score = -50;
            }

            if (baseToIndex.hasOwnProperty(base)) {
                const idx = baseToIndex[base];
                if (score > orderedGroups[idx].score) {
                    orderedGroups[idx].url = img.URL;
                    orderedGroups[idx].score = score;
                    if (img.Alt) orderedGroups[idx].alt = img.Alt;
                }
            } else {
                baseToIndex[base] = orderedGroups.length;
                orderedGroups.push({
                    url: img.URL,
                    alt: img.Alt,
                    score: score,
                    base: base
                });
            }
        });

        outputData.images = orderedGroups.map(e => ({
            url: e.url,
            alt_text: e.alt
        }));

        // Name
        let name = "";
        if (jsonData) name = jsonData.name || "";
        if (!name) name = $("h1.product-name").first().text().trim();
        outputData.name = name;

        outputData.preDiscountPrice = null;

        // Price
        let price = 0;
        if (jsonData && jsonData.offers) {
            price = parseFloat(jsonData.offers.price) || 0;
        }
        if (price === 0) {
            const pText = $(".product-offer .price").first().text();
            const match = pText.match(/[\d,.]+/);
            if (match) {
                price = parseFloat(match[0].replace(/,/g, '')) || 0;
            }
        }
        outputData.price = price;

        // Product ID
        let productId = "";
        if (jsonData && jsonData.url) {
            const parts = jsonData.url.replace(/\/$/, "").split("/");
            productId = parts[parts.length - 1];
        }
        if (!productId) {
            productId = $(".product-page").attr("data-product-id") || 
                        $("[data-product-id]").first().attr("data-product-id") || "";
        }
        if (!productId) {
            const canonical = $("link[rel='canonical']").attr("href") || "";
            if (canonical) {
                const parts = canonical.replace(/\/$/, "").split("/");
                productId = parts[parts.length - 1];
            }
        }
        if (!productId) {
            const ogUrl = $("meta[property='og:url']").attr("content") || "";
            if (ogUrl) {
                const parts = ogUrl.replace(/\/$/, "").split("/");
                productId = parts[parts.length - 1];
            }
        }
        outputData.productId = productId;

        outputData.reviews = [];

        // Seller
        let sellerName = "";
        let sellerUrl = "";
        const sellerAnchor = $(".seller-info a").first();
        if (sellerAnchor.length > 0) {
            sellerName = sellerAnchor.text().trim();
            sellerUrl = makeAbsoluteURL(sellerAnchor.attr("href") || "");
        } else {
            sellerName = $(".seller-info .seller-name").first().text().trim();
        }

        if (!sellerName) {
            const brandAnchor = $(".brand-name a").first();
            if (brandAnchor.length > 0) {
                sellerName = brandAnchor.text().trim();
                sellerUrl = makeAbsoluteURL(brandAnchor.attr("href") || "");
            }
        }

        if (!sellerName && jsonData && jsonData.offers && jsonData.offers.seller) {
            sellerName = jsonData.offers.seller.name || "";
            sellerUrl = makeAbsoluteURL(jsonData.offers.seller.url || "");
        }

        if ((!sellerName || sellerName === "Beautylish") && !sellerUrl) {
            sellerName = "Beautylish";
            sellerUrl = "https://www.beautylish.com";
        }

        outputData.seller = sellerName ? { name: sellerName, rating: null, url: sellerUrl } : null;

        outputData.serialNumbers = [];

        // Specifications
        let specs = [];
        $(".product-specifications .spec-item").each((i, el) => {
            let key = $(el).find(".key").text().trim().replace(/:$/, "").trim();
            let val = $(el).find(".value").text().trim();
            if (!val) {
                const fullText = $(el).text();
                if (fullText.includes(":")) {
                    val = fullText.split(":")[1].trim();
                }
            }
            if (key && val) specs.push({ key, value: val });
        });

        if (specs.length === 0 && jsonData && jsonData.description) {
            const $temp = cheerio.load(jsonData.description);
            $temp("li").each((i, li) => {
                const itemText = $temp(li).text().trim();
                if (itemText.includes(":")) {
                    const parts = itemText.split(":");
                    const key = parts[0].trim();
                    const val = parts.slice(1).join(":").trim();
                    if (key.length < 30 && val.length < 100) {
                        specs.push({ key, value: val });
                    }
                } else if (itemText.length > 0 && itemText.length < 40) {
                    let key = "Dietary";
                    if (itemText.toLowerCase().includes("approved") || itemText.toLowerCase().includes("certified")) {
                        key = "Certification";
                    }
                    specs.push({ key, value: itemText });
                }
            });
        }

        if (specs.length === 0) {
            $("h5").each((i, el) => {
                const title = $(el).text().toLowerCase();
                if (title.includes("key ingredients") || title.includes("specifications")) {
                    $(el).nextAll("ul").first().find("li").each((j, li) => {
                        const text = $(li).text().trim();
                        if (text.includes(":")) {
                            const parts = text.split(":");
                            const key = parts[0].trim();
                            const val = parts.slice(1).join(":").trim();
                            if (key.length < 30) specs.push({ key, value: val });
                        } else if (text.length > 0 && text.length < 40) {
                            let key = "Dietary";
                            if (text.toLowerCase().includes("approved")) key = "Certification";
                            specs.push({ key, value: text });
                        }
                    });
                }
            });
        }
        outputData.specifications = specs;

        // Final URL
        let pageUrl = jsonData ? jsonData.url : "";
        if (!pageUrl) pageUrl = $("link[rel='canonical']").attr("href") || "";
        outputData.url = makeAbsoluteURL(pageUrl || url);

        // Videos
        const videos = [];
        const seenVideos = new Set();
        const safeMakeAbsolute = (u) => makeAbsoluteURL(u);

        $("script.js-video-data").each((i, el) => {
            const content = $(el).text().trim();
            if (!content) return;
            try {
                const vData = JSON.parse(content);
                const vList = Array.isArray(vData) ? vData : [vData];
                vList.forEach(item => {
                    const u = item.url || "";
                    if (u) {
                        const abs = safeMakeAbsolute(u);
                        if (abs && !seenVideos.has(abs)) {
                            videos.push({ url: abs });
                            seenVideos.add(abs);
                        }
                    }
                });
            } catch (e) {}
        });

        if (videos.length === 0) {
            $("video source, video").each((i, el) => {
                const videoURL = $(el).attr("src") || $(el).attr("data-src") || "";
                if (videoURL) {
                    const abs = safeMakeAbsolute(videoURL);
                    if (abs && !seenVideos.has(abs)) {
                        videos.push({ url: abs });
                        seenVideos.add(abs);
                    }
                }
            });
        }

        if (videos.length === 0) {
            $("script").each((i, el) => {
                const content = $(el).text();
                if (content.includes(".mp4") || content.includes(".m3u8")) {
                    const re = /"((?:https?:)?\/\/[^"\s]+\.(?:mp4|m3u8)(?:[^"\s]*))"/g;
                    let m;
                    while ((m = re.exec(content)) !== null) {
                        const abs = safeMakeAbsolute(m[1]);
                        if (abs && !seenVideos.has(abs)) {
                            videos.push({ url: abs });
                            seenVideos.add(abs);
                        }
                    }
                }
            });
        }
        outputData.videos = videos;

        return outputData;
    } catch (error) {
        console.error('Error extracting data from', url, ':', error);
        return null;
    }
}

/**
 * Scrape a single page with retry logic using Puppeteer with stealth
 * @param {string} url - URL to scrape
 * @param {DataPipeline} pipeline - Data pipeline instance
 * @param {Object} browser - Puppeteer browser instance
 * @param {number} retries - Number of retries
 */
async function scrapePage(url, pipeline, browser, retries = CONFIG.maxRetries) {
    let success = false;
    let attempts = 0;

    while (attempts <= retries && !success) {
        let page = null;
        
        try {
            page = await browser.newPage();
            
            // Set viewport
            await page.setViewport({ width: 1920, height: 1080 });
            
            // Set user agent
            await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36');
            
            // Block unnecessary resources for performance optimization
            await page.setRequestInterception(true);
            page.on('request', (request) => {
                const resourceType = request.resourceType();
                if (['image', 'media', 'font', 'stylesheet'].includes(resourceType)) {
                    request.abort();
                } else {
                    request.continue();
                }
            });
            
            // Authenticate with proxy
            await page.authenticate({
                username: PROXY_USERNAME,
                password: PROXY_PASSWORD
            });
            
            // Navigate with optimized wait strategy
            await page.goto(url, { 
                waitUntil: 'domcontentloaded',
                timeout: CONFIG.timeout 
            });
            
            // Wait for product content to be present
            try {
                await page.waitForSelector('.product-page, [data-product-id], script[type="application/ld+json"]', { timeout: 10000 });
            } catch (e) {
                console.warn('Timeout waiting for selector, proceeding with current HTML');
            }
            
            const bodyHTML = await page.evaluate(() => document.body.innerHTML);
            const $ = cheerio.load(bodyHTML);
            
            const scrapedData = extractData($, url);
            
            if (scrapedData && (scrapedData.name || scrapedData.productId)) {
                await pipeline.addData(scrapedData);
                success = true;
                console.log('Successfully scraped:', url);
            } else {
                console.warn('No valid data extracted from:', url);
            }
        } catch (error) {
            console.error('Exception scraping', url, ':', error.message);
            
            if (attempts < retries) {
                const delay = Math.pow(2, attempts) * 1000;
                console.log('Retrying in', delay, 'ms...');
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        } finally {
            if (page) await page.close();
            attempts++;
        }
    }

    if (!success) {
        console.error('Failed to scrape', url, 'after', retries, 'retries');
    }
}

/**
 * Scrape multiple URLs concurrently with controlled concurrency
 * @param {string[]} urls - Array of URLs to scrape
 */
async function concurrentScraping(urls) {
    const pipeline = new DataPipeline(CONFIG.outputFile);
    
    // Launch browser with performance optimizations
    const browser = await puppeteer.launch({
        headless: 'new',
        ignoreHTTPSErrors: true,
        args: [
            `--proxy-server=http://${PROXY_SERVER}:${PROXY_PORT}`,
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-accelerated-2d-canvas',
            '--no-first-run',
            '--no-zygote',
            '--disable-gpu',
            '--disable-web-security'
        ]
    });

    try {
        // Process URLs in batches to control concurrency
        for (let i = 0; i < urls.length; i += CONFIG.maxConcurrency) {
            const batch = urls.slice(i, i + CONFIG.maxConcurrency);
            const promises = batch.map(url => scrapePage(url, pipeline, browser, CONFIG.maxRetries));
            
            try {
                await Promise.all(promises);
                console.log('Completed batch', Math.floor(i / CONFIG.maxConcurrency) + 1, 'of', Math.ceil(urls.length / CONFIG.maxConcurrency));
            } catch (error) {
                console.error('Error in batch processing:', error);
            }
        }
    } finally {
        await browser.close();
    }
}

/**
 * Main execution function
 */
async function main() {
    const urls = [
        'https://www.beautylish.com/s/vital-proteins-vanilla-collagen-creamer-10-6-oz',
    ];

    console.log('Starting concurrent scraping with NodeJS Puppeteer-Extra + Stealth...');
    console.log('URLs to scrape:', urls.length);
    console.log('Max concurrency:', CONFIG.maxConcurrency);
    console.log('Output file:', CONFIG.outputFile);

    try {
        await concurrentScraping(urls);
        console.log('Scraping completed successfully!');
    } catch (error) {
        console.error('Scraping failed:', error);
        process.exit(1);
    }
}

// Run the scraper if this file is executed directly
if (require.main === module) {
    main().catch(console.error);
}

module.exports = { extractData, scrapePage, concurrentScraping, DataPipeline };