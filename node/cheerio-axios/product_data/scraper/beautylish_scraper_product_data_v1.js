/**
 * Generated by: ScrapeOps AI Scraper Generator on 2026-02-16
 * Signup For Free Beta: https://scrapeops.io/app/register/ai-scraper-generator
 * Docs & Updates: https://scrapeops.io/docs/ai-scraper-generator
 * For Support & Feedback Email: ai-scraper-generator@scrapeops.io
 */

const axios = require('axios');
const cheerio = require('cheerio');
const fs = require('fs');
const { promisify } = require('util');

const API_KEY = 'YOUR-API_KEY';

/**
 * Generate output filename with current timestamp
 * @returns {string} Output filename
 */
function generateOutputFilename() {
    const now = new Date();
    const timestamp = now.getFullYear().toString() +
        (now.getMonth() + 1).toString().padStart(2, '0') +
        now.getDate().toString().padStart(2, '0') + '_' +
        now.getHours().toString().padStart(2, '0') +
        now.getMinutes().toString().padStart(2, '0') +
        now.getSeconds().toString().padStart(2, '0');
    return 'beautylish_com_product_page_scraper_data_' + timestamp + '.jsonl';
}

// Configuration
const CONFIG = {
    maxRetries: 3,
    maxConcurrency: 1,
    timeout: 30000,
    outputFile: generateOutputFilename()
};

/**
 * Data pipeline for handling scraped data
 */
class DataPipeline {
    constructor(outputFile = CONFIG.outputFile) {
        this.itemsSeen = new Set();
        this.outputFile = outputFile;
        this.writeFile = promisify(fs.appendFile);
    }

    /**
     * Check if item is duplicate based on unique identifier
     * @param {Object} data - Scraped data object
     * @returns {boolean} - True if duplicate
     */
    isDuplicate(data) {
        const itemKey = data.productId || JSON.stringify(data);
        if (this.itemsSeen.has(itemKey)) {
            console.warn('Duplicate item found, skipping:', itemKey.toString().substring(0, 100));
            return true;
        }
        this.itemsSeen.add(itemKey);
        return false;
    }

    /**
     * Add scraped data to output file
     * @param {Object} scrapedData - Data to save
     */
    async addData(scrapedData) {
        if (!this.isDuplicate(scrapedData)) {
            try {
                const jsonLine = JSON.stringify(scrapedData) + '\n';
                await this.writeFile(this.outputFile, jsonLine, 'utf8');
                console.log('Saved item to', this.outputFile);
            } catch (error) {
                console.error('Error saving data:', error);
            }
        }
    }
}

/**
 * Extract structured data from HTML using Cheerio
 * @param {Object} $ - Cheerio instance
 * @param {string} url - Source URL
 * @returns {Object|null} - Extracted data or null
 */
function extractData($, url) {
    try {
        const makeAbsoluteURL = (urlStr) => {
            if (!urlStr) return "";
            if (urlStr.startsWith("http://") || urlStr.startsWith("https://")) return urlStr;
            if (urlStr.startsWith("//")) return "https:" + urlStr;
            const domain = "https://www.beautylish.com";
            if (urlStr.startsWith("/")) return domain + urlStr;
            return domain + "/" + urlStr;
        };

        const detectCurrency = (priceText) => {
            const text = priceText.toUpperCase();
            const currencyMap = {
                "USD": "USD", "US$": "USD", "US $": "USD", "$": "USD",
                "EUR": "EUR", "€": "EUR",
                "GBP": "GBP", "£": "GBP", "GB£": "GBP",
                "JPY": "JPY", "¥": "JPY", "JP¥": "JPY",
                "CAD": "CAD", "CA$": "CAD", "C$": "CAD",
                "AUD": "AUD", "AU$": "AUD", "A$": "AUD",
                "CNY": "CNY", "CN¥": "CNY", "RMB": "CNY",
                "CHF": "CHF", "FR.": "CHF",
                "SEK": "SEK", "KR": "SEK",
                "NZD": "NZD", "NZ$": "NZD",
            };
            for (const [code, currency] of Object.entries(currencyMap)) {
                if (text.includes(code)) return currency;
            }
            return "USD";
        };

        // Extract JSON-LD
        let jsonData = null;
        $("script[type='application/ld+json']").each((i, el) => {
            try {
                const data = JSON.parse($(el).text());
                const objects = Array.isArray(data) ? data : [data];
                for (const obj of objects) {
                    if (obj["@type"] && obj["@type"].toLowerCase() === "product") {
                        jsonData = obj;
                        return false;
                    }
                }
            } catch (e) {}
        });

        const outputData = {};

        // Aggregate Rating
        const aggRating = {
            bestRating: null,
            ratingValue: null,
            reviewCount: null,
            worstRating: null
        };
        if (jsonData && jsonData.aggregateRating) {
            const ar = jsonData.aggregateRating;
            if (ar.ratingValue) aggRating.ratingValue = parseFloat(ar.ratingValue);
            if (ar.reviewCount) aggRating.reviewCount = parseInt(ar.reviewCount, 10);
        }
        outputData.aggregateRating = aggRating;

        // Availability
        let availability = "out_of_stock";
        if (jsonData && jsonData.offers && jsonData.offers.availability) {
            if (jsonData.offers.availability.includes("InStock")) {
                availability = "in_stock";
            }
        } else {
            const availLink = $("link[itemprop='availability']").attr("href") || "";
            if (availLink.includes("InStock")) {
                availability = "in_stock";
            }
        }
        outputData.availability = availability;

        // Brand
        let brand = "";
        if (jsonData && jsonData.brand) {
            brand = typeof jsonData.brand === 'string' ? jsonData.brand : (jsonData.brand.name || "");
        }
        if (!brand) {
            brand = $(".brand .brand-link").first().text().trim();
        }
        outputData.brand = brand;
        outputData.category = null;

        // Currency
        let currency = "USD";
        if (jsonData && jsonData.offers && jsonData.offers.priceCurrency) {
            currency = jsonData.offers.priceCurrency;
        }
        if (currency === "USD") {
            const priceContainer = $(".price-container").text();
            currency = detectCurrency(priceContainer);
        }
        outputData.currency = currency;

        // Description
        let description = "";
        if (jsonData && jsonData.description) {
            description = jsonData.description;
        }
        if (!description) {
            description = $(".description").html()?.trim() || "";
        }
        outputData.description = description;

        // Features
        let features = [];
        // Strategy 1
        $("ul.features li").each((i, el) => {
            const text = $(el).text().trim();
            if (text) features.push(text);
        });

        // Strategy 2
        if (features.length === 0 && description.includes("<li>")) {
            const $desc = cheerio.load(description);
            $desc("h5").each((i, el) => {
                const headerText = $desc(el).text().toLowerCase();
                if (headerText.includes("special") || headerText.includes("key ingredients") || headerText.includes("features")) {
                    $desc(el).nextAll("ul").first().find("li").each((j, li) => {
                        const text = $desc(li).text().trim();
                        if (text) features.push(text);
                    });
                }
            });
        }

        // Strategy 3
        if (features.length === 0) {
            $(".description h5, .product-info h5").each((i, el) => {
                const headerText = $(el).text().toLowerCase();
                if (headerText.includes("special") || headerText.includes("key ingredients") || headerText.includes("features")) {
                    $(el).nextAll("ul").first().find("li").each((j, li) => {
                        const text = $(li).text().trim();
                        if (text) features.push(text);
                    });
                }
            });
        }
        outputData.features = [...new Set(features)];

        // Images
        let images = [];
        const seenImages = new Set();
        $("div[data-section='product-carousel'] img, .product-images img, .product-image img").each((i, el) => {
            let imgUrl = $(el).attr("src") || $(el).attr("data-src") || $(el).attr("data-zoom-image") || "";
            if (imgUrl && !imgUrl.includes("afterpay") && !imgUrl.includes("sezzle")) {
                const fullResUrl = makeAbsoluteURL(imgUrl.replace("p_85x85", "zb_p"));
                if (!seenImages.has(fullResUrl)) {
                    images.push({
                        url: fullResUrl,
                        altText: $(el).attr("alt")?.trim() || ""
                    });
                    seenImages.add(fullResUrl);
                }
            }
        });

        if (images.length === 0 && jsonData?.image) {
            const fallbackAlt = jsonData.name || "";
            const imgList = Array.isArray(jsonData.image) ? jsonData.image : [jsonData.image];
            imgList.forEach(img => {
                const fullUrl = makeAbsoluteURL(img);
                if (!seenImages.has(fullUrl)) {
                    images.push({ url: fullUrl, altText: fallbackAlt });
                    seenImages.add(fullUrl);
                }
            });
        }
        outputData.images = images;

        // Name
        let name = jsonData?.name || $("h1.product-name").first().text().trim();
        outputData.name = name;
        outputData.preDiscountPrice = null;

        // Price
        let price = 0;
        if (jsonData?.offers?.price) {
            price = parseFloat(jsonData.offers.price);
        }
        if (!price) {
            const priceStr = $(".price").attr("data-price") || $(".price").first().text();
            const match = priceStr.match(/[\d,]+\.?\d*/);
            if (match) {
                price = parseFloat(match[0].replace(/,/g, ""));
            }
        }
        outputData.price = price;

        // ProductID
        let productID = $(".product-info").attr("data-product-id") || "";
        if (!productID) {
            const canonical = $("link[rel='canonical']").attr("href") || jsonData?.url || "";
            if (canonical) {
                const parts = canonical.replace(/\/+$/, "").split("/");
                productID = parts[parts.length - 1];
            }
        }
        outputData.productId = productID;
        outputData.reviews = [];

        // Seller
        const seller = { name: "Beautylish", rating: null, url: "https://www.beautylish.com" };
        const sellerLink = $(".seller-info .seller-name");
        if (sellerLink.length > 0) {
            seller.name = sellerLink.text().trim();
            const href = sellerLink.attr("href");
            if (href) seller.url = makeAbsoluteURL(href);
        }
        outputData.seller = seller;
        outputData.serialNumbers = [];

        // Specifications
        let specifications = [];
        $(".specifications .spec-item, .product-specs .spec-item").each((i, el) => {
            const keySpan = $(el).find(".key");
            const valSpan = $(el).find(".value");
            let k, v;
            if (keySpan.length && valSpan.length) {
                k = keySpan.text().trim();
                v = valSpan.text().trim();
            } else {
                [k, v] = $(el).text().split(":").map(s => s.trim());
            }
            k = k?.replace(/:$/, "");
            if (k && v) specifications.push({ key: k, value: v });
        });

        if (specifications.length === 0) {
            $("h5:contains('Other Details') + ul li, .description h5:contains('Details') + ul li").each((i, el) => {
                const text = $(el).text().trim();
                if (text.includes(":")) {
                    const [k, v] = text.split(":").map(s => s.trim());
                    specifications.push({ key: k, value: v });
                } else if (text) {
                    const dietaryKeywords = ["Gluten-Free", "Dairy-Free", "No Sugar", "Paleo", "Whole 30"];
                    const isDietary = dietaryKeywords.some(kw => text.includes(kw));
                    specifications.push({ key: isDietary ? "Dietary" : "Feature", value: text });
                }
            });
        }
        outputData.specifications = specifications;

        // URL
        const canonicalUrl = jsonData?.url || $("link[rel='canonical']").attr("href") || url;
        outputData.url = makeAbsoluteURL(canonicalUrl);

        // Videos
        let videos = [];
        const seenVideoUrls = new Set();
        const processVideo = (v) => {
            if (v && v.url) {
                const cleanURL = makeAbsoluteURL(v.url.replace(/\\\//g, "/"));
                if (!seenVideoUrls.has(cleanURL)) {
                    videos.push({ url: cleanURL });
                    seenVideoUrls.add(cleanURL);
                }
            }
        };

        $("script.video-data").each((i, el) => {
            const content = $(el).text().trim() || $(el).html()?.trim();
            if (!content) return;
            try {
                const raw = JSON.parse(content);
                Array.isArray(raw) ? raw.forEach(processVideo) : processVideo(raw);
            } catch (e) {
                const urlRegex = /"url"\s*:\s*"([^"]+)"/g;
                let m;
                while ((m = urlRegex.exec(content)) !== null) {
                    processVideo({ url: m[1] });
                }
            }
        });

        outputData.videos = videos;
        outputData.timestamp = new Date().toISOString();

        return outputData;
    } catch (error) {
        console.error('Error extracting data from', url, ':', error);
        return null;
    }
}

/**
 * Create axios instance with proper configuration
 */
function createAxiosInstance() {
    return axios.create({
        timeout: CONFIG.timeout,
        headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
    });
}

/**
 * Scrape a single page with retry logic
 * @param {string} url - URL to scrape
 * @param {DataPipeline} pipeline - Data pipeline instance
 * @param {number} retries - Number of retries
 */
async function scrapePage(url, pipeline, retries = CONFIG.maxRetries) {
    const axiosInstance = createAxiosInstance();
    
    const payload = {
        api_key: API_KEY,
        url: url,
        optimize_request: true 
    };

    let success = false;
    let attempts = 0;

    while (attempts <= retries && !success) {
        try {
            const proxyUrl = 'https://proxy.scrapeops.io/v1/?' + new URLSearchParams(payload);
            const response = await axiosInstance.get(proxyUrl);

            if (response.status === 200) {
                const $ = cheerio.load(response.data);
                const scrapedData = extractData($, url);
                
                if (scrapedData) {
                    await pipeline.addData(scrapedData);
                    success = true;
                    console.log('Successfully scraped:', url);
                } else {
                    console.warn('No data extracted from:', url);
                }
            } else {
                console.warn('Request failed for', url, 'with status', response.status);
            }
        } catch (error) {
            console.error('Exception scraping', url, ':', error.message);
            if (attempts < retries) {
                const delay = Math.pow(2, attempts) * 1000;
                console.log('Retrying in', delay, 'ms...');
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        } finally {
            attempts++;
        }
    }

    if (!success) {
        console.error('Failed to scrape', url, 'after', retries, 'retries');
    }
}

/**
 * Scrape multiple URLs concurrently with controlled concurrency
 */
async function concurrentScraping(urls, maxConcurrency = CONFIG.maxConcurrency, maxRetries = CONFIG.maxRetries, outputFile = CONFIG.outputFile) {
    const pipeline = new DataPipeline(outputFile);
    for (let i = 0; i < urls.length; i += maxConcurrency) {
        const batch = urls.slice(i, i + maxConcurrency);
        const promises = batch.map(url => scrapePage(url, pipeline, maxRetries));
        try {
            await Promise.all(promises);
            console.log('Completed batch', Math.floor(i / maxConcurrency) + 1, 'of', Math.ceil(urls.length / maxConcurrency));
        } catch (error) {
            console.error('Error in batch processing:', error);
        }
    }
}

/**
 * Main execution function
 */
async function main() {
    const urls = [
        'https://www.beautylish.com/s/vital-proteins-vanilla-collagen-creamer-10-6-oz',
    ];

    console.log('Starting concurrent scraping with NodeJS Cheerio & Axios...');
    console.log('URLs to scrape:', urls.length);
    console.log('Max concurrency:', CONFIG.maxConcurrency);
    console.log('Output file:', CONFIG.outputFile);

    try {
        await concurrentScraping(urls, CONFIG.maxConcurrency, CONFIG.maxRetries, CONFIG.outputFile);
        console.log('Scraping completed successfully!');
    } catch (error) {
        console.error('Scraping failed:', error);
        process.exit(1);
    }
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = { extractData, scrapePage, concurrentScraping, DataPipeline };