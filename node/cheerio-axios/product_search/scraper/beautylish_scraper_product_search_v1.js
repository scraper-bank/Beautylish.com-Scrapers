/**
 * Generated by: ScrapeOps AI Scraper Generator on 2026-02-16
 * Signup For Free Beta: https://scrapeops.io/app/register/ai-scraper-generator
 * Docs & Updates: https://scrapeops.io/docs/ai-scraper-generator
 * For Support & Feedback Email: ai-scraper-generator@scrapeops.io
 */

const axios = require('axios');
const cheerio = require('cheerio');
const fs = require('fs');
const { promisify } = require('util');

const API_KEY = 'YOUR-API_KEY';

/**
 * Generate output filename with current timestamp
 * @returns {string} Output filename
 */
function generateOutputFilename() {
    const now = new Date();
    const timestamp = now.getFullYear().toString() +
        (now.getMonth() + 1).toString().padStart(2, '0') +
        now.getDate().toString().padStart(2, '0') + '_' +
        now.getHours().toString().padStart(2, '0') +
        now.getMinutes().toString().padStart(2, '0') +
        now.getSeconds().toString().padStart(2, '0');
    return 'beautylish_com_product_search_page_scraper_data_' + timestamp + '.jsonl';
}

// Configuration
const CONFIG = {
    maxRetries: 3,
    maxConcurrency: 1,
    timeout: 30000,
    outputFile: generateOutputFilename()
};

/**
 * Data pipeline for handling scraped data
 */
class DataPipeline {
    constructor(outputFile = CONFIG.outputFile) {
        this.itemsSeen = new Set();
        this.outputFile = outputFile;
        this.writeFile = promisify(fs.appendFile);
    }

    /**
     * Check if item is duplicate based on unique identifier
     * @param {Object} data - Scraped data object
     * @returns {boolean} - True if duplicate
     */
    isDuplicate(data) {
        const itemKey = data.productId || JSON.stringify(data);
        if (this.itemsSeen.has(itemKey)) {
            console.warn('Duplicate item found, skipping:', String(itemKey).substring(0, 100));
            return true;
        }
        this.itemsSeen.add(itemKey);
        return false;
    }

    /**
     * Add scraped data to output file
     * @param {Object} scrapedData - Data to save
     */
    async addData(scrapedData) {
        if (scrapedData && scrapedData.products) {
            for (const product of scrapedData.products) {
                if (!this.isDuplicate(product)) {
                    try {
                        const jsonLine = JSON.stringify(product) + '\n';
                        await this.writeFile(this.outputFile, jsonLine, 'utf8');
                        console.log('Saved item to', this.outputFile);
                    } catch (error) {
                        console.error('Error saving data:', error);
                    }
                }
            }
        }
    }
}

/**
 * Utility functions for data extraction
 */
const stripHTML = (htmlStr) => {
    if (!htmlStr) return "";
    return htmlStr.replace(/<[^>]*>/g, ' ').trim();
};

const makeAbsoluteURL = (urlStr) => {
    if (!urlStr) return "";
    if (urlStr.startsWith("http://") || urlStr.startsWith("https://")) return urlStr;
    if (urlStr.startsWith("//")) return "https:" + urlStr;
    const domain = "https://www.beautylish.com";
    if (urlStr.startsWith("/")) return domain + urlStr;
    return domain + "/" + urlStr;
};

const detectCurrency = (priceText) => {
    if (!priceText) return "USD";
    const text = priceText.toUpperCase();
    const currencyMap = {
        "USD": "USD", "US$": "USD", "US $": "USD", "$": "USD",
        "EUR": "EUR", "€": "EUR",
        "GBP": "GBP", "£": "GBP", "GB£": "GBP",
        "JPY": "JPY", "¥": "JPY", "JP¥": "JPY",
        "CAD": "CAD", "CA$": "CAD", "C$": "CAD",
        "AUD": "AUD", "AU$": "AUD", "A$": "AUD",
        "CNY": "CNY", "CN¥": "CNY", "RMB": "CNY",
        "CHF": "CHF", "FR.": "CHF",
        "SEK": "SEK", "KR": "SEK",
        "NZD": "NZD", "NZ$": "NZD",
    };
    for (const [code, currency] of Object.entries(currencyMap)) {
        if (text.includes(code)) return currency;
    }
    return "USD";
};

const extractNumericPrice = (priceText) => {
    if (!priceText) return 0;
    const cleanText = String(priceText).replace(/,/g, '');
    const match = cleanText.match(/[\d,]+\.?\d*/);
    if (match) {
        return parseFloat(match[0]);
    }
    return 0;
};

/**
 * Extract structured data from HTML using Cheerio
 * @param {Object} $ - Cheerio instance
 * @param {string} url - Source URL
 * @returns {Object|null} - Extracted data or null
 */
function extractData($, url) {
    try {
        const outputData = {
            breadcrumbs: [],
            pagination: null,
            products: [],
            recommendations: null,
            relatedSearches: null,
            searchMetadata: {
                query: "",
                resultsDisplayed: 0,
                searchType: "keyword",
                searchUrl: "https://www.beautylish.com/shop/browse?q=",
                totalResults: 0
            },
            sponsoredProducts: null
        };

        let products = [];

        // Strategy 1: JSON-LD
        $("script[type='application/ld+json']").each((i, el) => {
            try {
                const data = JSON.parse($(el).text());
                const items = data.itemListElement || [];
                items.forEach(item => {
                    const prod = item.item;
                    if (prod) {
                        const p = {
                            name: prod.name,
                            brand: prod.brand ? prod.brand.name : "",
                            url: makeAbsoluteURL(prod.url),
                            productId: String(prod.sku || ""),
                            images: prod.image ? [{ url: makeAbsoluteURL(prod.image), altText: "" }] : [],
                            price: 0,
                            currency: "USD",
                            availability: "in_stock"
                        };

                        if (prod.offers) {
                            p.price = typeof prod.offers.price === 'number' ? prod.offers.price : extractNumericPrice(prod.offers.price);
                            p.currency = String(prod.offers.priceCurrency || "USD");
                            if (String(prod.offers.availability).includes("OutOfStock")) {
                                p.availability = "oos";
                            }
                        }

                        if (p.name) products.push(p);
                    }
                });
            } catch (e) {}
        });

        // Strategy 2: Hydration Scripts
        if (products.length === 0) {
            $("script").each((i, el) => {
                const content = $(el).text();
                if (content.includes('"products":') || content.includes('"items":')) {
                    const match = content.match(/(?:"products"|"items")\s*:\s*(\[\s*\{.*?\}\s*\])/s);
                    if (match) {
                        try {
                            const rawProds = JSON.parse(match[1]);
                            rawProds.forEach(rp => {
                                if (!rp.name) return;
                                products.push({
                                    name: rp.name,
                                    productId: String(rp.id || ""),
                                    brand: rp.brand_name || (rp.brand ? rp.brand.name : ""),
                                    price: extractNumericPrice(rp.price),
                                    url: makeAbsoluteURL(rp.url)
                                });
                            });
                        } catch (e) {}
                    }
                }
            });
        }

        // Strategy 3: Standard DOM Extraction
        if (products.length === 0) {
            const selectors = ".product-card, [data-type='product'], .search-result-item, .product-grid-item, [itemprop='itemListElement'], .product, div[data-id], .grid-item, .ocnProductCard, .product_list li, .shop_browse_results li, .product-item, .product_item";
            $(selectors).each((i, el) => {
                const s = $(el);
                const p = {};

                const ratingValue = parseFloat(s.find("[itemprop='ratingValue'], .rating-value, .ocnProductCard_ratingValue, .rating, .star-rating").attr("content") || "0");
                const reviewCount = parseInt(s.find("[itemprop='reviewCount'], .review-count, .ocnProductCard_reviewCount, .count, .review-total").attr("content") || "0", 10);
                
                p.aggregateRating = {
                    bestRating: 5.0,
                    ratingValue: ratingValue,
                    reviewCount: reviewCount,
                    worstRating: 1.0
                };

                const text = s.text().toLowerCase();
                p.availability = (text.includes("out of stock") || text.includes("sold out")) ? "oos" : "in_stock";
                
                p.brand = s.find(".product-card__brand, .brand-name, [itemprop='brand'], .brand, .ocnProductCard_brand, .product-brand, .brand_name").first().text().trim();
                p.category = "";
                
                const priceRaw = s.find(".product-card__price, .price, [itemprop='price'], .product-price, .ocnProductCard_price, .current-price, .price_value").first().text();
                p.currency = detectCurrency(priceRaw);
                p.price = extractNumericPrice(priceRaw);

                const descHtml = s.find(".product-card__description, .description, .product-excerpt, .summary, .product-desc, .product_description").first().html();
                p.description = stripHTML(descHtml);
                p.features = [];

                let imgSrc = s.find("img.product-card__image, img.image, [itemprop='image'], .product-img, .ocnProductCard_image, .product-image img, .product_image").first().attr("src");
                if (!imgSrc) imgSrc = s.find("img").first().attr("data-src");
                if (!imgSrc) imgSrc = s.find("img").first().attr("data-lazy-src");

                p.images = imgSrc ? [{
                    altText: s.find("img").first().attr("alt") || "",
                    url: makeAbsoluteURL(imgSrc)
                }] : [];

                let name = s.find(".product-card__name, .product-name, [itemprop='name'], .name, .ocnProductCard_name, .product-title, .product_name").first().text().trim();
                if (!name) name = s.find("h3, h2, .title, .product-title, .product_title").first().text().trim();
                p.name = name;

                p.preDiscountPrice = null;
                const oldPriceText = s.find(".product-card__price--old, .original-price, .strike, .old-price, .was-price, .list-price").first().text();
                if (oldPriceText) p.preDiscountPrice = extractNumericPrice(oldPriceText);

                p.productId = s.attr("data-product-id") || s.attr("id") || s.attr("data-id") || "";
                p.reviews = [];
                p.seller = { name: "Beautylish", rating: 0.0, url: "https://www.beautylish.com" };
                p.serialNumbers = [];
                p.specifications = [];

                const pURL = s.find("a.product-card__link, a[itemprop='url'], a, .ocnProductCard_link, .product-link, .product_link").first().attr("href");
                p.url = makeAbsoluteURL(pURL);
                p.videos = [];

                if (p.name) products.push(p);
            });
        }

        outputData.products = products;
        
        // Search Metadata
        const queryVal = $("input[name='q']").first().attr("value");
        if (queryVal) {
            outputData.searchMetadata.query = queryVal;
            outputData.searchMetadata.searchUrl = "https://www.beautylish.com/shop/browse?q=" + queryVal.replace(/ /g, "+");
        } else {
            const canonical = $("link[rel='canonical']").attr("href");
            if (canonical && canonical.includes("q=")) {
                const qMatch = canonical.split("q=")[1]?.split("&")[0];
                if (qMatch) {
                    outputData.searchMetadata.query = decodeURIComponent(qMatch.replace(/\+/g, " "));
                    outputData.searchMetadata.searchUrl = "https://www.beautylish.com" + canonical;
                }
            }
        }
        outputData.searchMetadata.resultsDisplayed = products.length;
        outputData.searchMetadata.totalResults = products.length;

        return outputData;
    } catch (error) {
        console.error('Error extracting data from', url, ':', error);
        return null;
    }
}

/**
 * Create axios instance with proper configuration
 */
function createAxiosInstance() {
    return axios.create({
        timeout: CONFIG.timeout,
        headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
    });
}

/**
 * Scrape a single page with retry logic
 * @param {string} url - URL to scrape
 * @param {DataPipeline} pipeline - Data pipeline instance
 * @param {number} retries - Number of retries
 */
async function scrapePage(url, pipeline, retries = CONFIG.maxRetries) {
    const axiosInstance = createAxiosInstance();
    
    const payload = {
        api_key: API_KEY,
        url: url,
        optimize_request: true 
    };

    let success = false;
    let attempts = 0;

    while (attempts <= retries && !success) {
        try {
            const proxyUrl = 'https://proxy.scrapeops.io/v1/?' + new URLSearchParams(payload);
            const response = await axiosInstance.get(proxyUrl);

            if (response.status === 200) {
                const $ = cheerio.load(response.data);
                const scrapedData = extractData($, url);
                
                if (scrapedData) {
                    await pipeline.addData(scrapedData);
                    success = true;
                    console.log('Successfully scraped:', url);
                } else {
                    console.warn('No data extracted from:', url);
                }
            } else {
                console.warn('Request failed for', url, 'with status', response.status);
            }
        } catch (error) {
            console.error('Exception scraping', url, ':', error.message);
            if (attempts < retries) {
                const delay = Math.pow(2, attempts) * 1000;
                console.log('Retrying in', delay, 'ms...');
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        } finally {
            attempts++;
        }
    }

    if (!success) {
        console.error('Failed to scrape', url, 'after', retries, 'retries');
    }
}

/**
 * Scrape multiple URLs concurrently with controlled concurrency
 * @param {string[]} urls - Array of URLs to scrape
 * @param {number} maxConcurrency - Maximum concurrent requests
 * @param {number} maxRetries - Maximum retries per URL
 * @param {string} outputFile - Output file path
 */
async function concurrentScraping(urls, maxConcurrency = CONFIG.maxConcurrency, maxRetries = CONFIG.maxRetries, outputFile = CONFIG.outputFile) {
    const pipeline = new DataPipeline(outputFile);
    
    for (let i = 0; i < urls.length; i += maxConcurrency) {
        const batch = urls.slice(i, i + maxConcurrency);
        const promises = batch.map(url => scrapePage(url, pipeline, maxRetries));
        
        try {
            await Promise.all(promises);
            console.log('Completed batch', Math.floor(i / maxConcurrency) + 1, 'of', Math.ceil(urls.length / maxConcurrency));
        } catch (error) {
            console.error('Error in batch processing:', error);
        }
    }
}

/**
 * Main execution function
 */
async function main() {
    const urls = [
        'https://www.beautylish.com/shop/browse?utm_source=internal_search&utm_campaign=Search+Beautylish+Products&q=hair+shampoo',
    ];

    console.log('Starting concurrent scraping with NodeJS Cheerio & Axios...');
    console.log('URLs to scrape:', urls.length);
    console.log('Max concurrency:', CONFIG.maxConcurrency);
    console.log('Output file:', CONFIG.outputFile);

    try {
        await concurrentScraping(urls, CONFIG.maxConcurrency, CONFIG.maxRetries, CONFIG.outputFile);
        console.log('Scraping completed successfully!');
    } catch (error) {
        console.error('Scraping failed:', error);
        process.exit(1);
    }
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = { extractData, scrapePage, concurrentScraping, DataPipeline };