/**
 * Generated by: ScrapeOps AI Scraper Generator on 2026-02-16
 * Signup For Free Beta: https://scrapeops.io/app/register/ai-scraper-generator
 * Docs & Updates: https://scrapeops.io/docs/ai-scraper-generator
 * For Support & Feedback Email: ai-scraper-generator@scrapeops.io
 */

const { chromium } = require('playwright-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
const cheerio = require('cheerio');
const fs = require('fs');
const { promisify } = require('util');

// Add stealth plugin
chromium.use(StealthPlugin());

const API_KEY = 'YOUR-API_KEY';

/**
 * Generate output filename with current timestamp
 * @returns {string} Output filename
 */
function generateOutputFilename() {
    const now = new Date();
    const timestamp = now.getFullYear().toString() +
        (now.getMonth() + 1).toString().padStart(2, '0') +
        now.getDate().toString().padStart(2, '0') + '_' +
        now.getHours().toString().padStart(2, '0') +
        now.getMinutes().toString().padStart(2, '0') +
        now.getSeconds().toString().padStart(2, '0');
    return 'beautylish_com_product_page_scraper_data_' + timestamp + '.jsonl';
}

// ScrapeOps Residential Proxy Configuration
const PROXY_CONFIG = {
    server: 'http://residential-proxy.scrapeops.io:8181',
    username: 'scrapeops',
    password: API_KEY
};

// Configuration
const CONFIG = {
    maxRetries: 3,
    maxConcurrency: 1,
    timeout: 180000,
    outputFile: generateOutputFilename()
};

/**
 * Data pipeline for handling scraped data
 */
class DataPipeline {
    constructor(outputFile = CONFIG.outputFile) {
        this.itemsSeen = new Set();
        this.outputFile = outputFile;
        this.writeFile = promisify(fs.appendFile);
    }

    isDuplicate(data) {
        const itemKey = JSON.stringify(data);
        if (this.itemsSeen.has(itemKey)) {
            console.warn('Duplicate item found, skipping');
            return true;
        }
        this.itemsSeen.add(itemKey);
        return false;
    }

    async addData(scrapedData) {
        if (!this.isDuplicate(scrapedData)) {
            try {
                const jsonLine = JSON.stringify(scrapedData) + '\n';
                await this.writeFile(this.outputFile, jsonLine, 'utf8');
                console.log('Saved item to', this.outputFile);
            } catch (error) {
                console.error('Error saving data:', error);
            }
        }
    }
}

/**
 * Extract structured data from HTML using Cheerio
 * @param {Object} $ - Cheerio instance
 * @param {string} url - Source URL
 * @returns {Object|null} - Extracted data or null
 */
function extractData($, url) {
    try {
        const domain = "https://www.beautylish.com";

        const makeAbsoluteURL = (urlStr) => {
            if (!urlStr) return "";
            if (urlStr.startsWith("http://") || urlStr.startsWith("https://")) return urlStr;
            if (urlStr.startsWith("//")) return "https:" + urlStr;
            if (urlStr.startsWith("/")) return domain + urlStr;
            return domain + "/" + urlStr;
        };

        const detectCurrency = (priceText) => {
            const text = priceText.toUpperCase();
            const currencyMap = {
                "USD": "USD", "US$": "USD", "US $": "USD", "$": "USD",
                "EUR": "EUR", "€": "EUR",
                "GBP": "GBP", "£": "GBP", "GB£": "GBP",
                "JPY": "JPY", "¥": "JPY", "JP¥": "JPY",
                "CAD": "CAD", "CA$": "CAD", "C$": "CAD",
                "AUD": "AUD", "AU$": "AUD", "A$": "AUD",
                "CNY": "CNY", "CN¥": "CNY", "RMB": "CNY",
                "CHF": "CHF", "FR.": "CHF",
                "SEK": "SEK", "KR": "SEK",
                "NZD": "NZD", "NZ$": "NZD",
            };
            for (const [code, currency] of Object.entries(currencyMap)) {
                if (text.includes(code)) return currency;
            }
            return "USD";
        };

        let jsonLD = null;
        $("script[type='application/ld+json']").each((i, el) => {
            try {
                const data = JSON.parse($(el).text());
                if (data && data["@type"] && data["@type"].toLowerCase() === "product") {
                    jsonLD = data;
                }
            } catch (e) {}
        });

        const outputData = {};

        // Name
        let name = "";
        if (jsonLD && jsonLD.name) name = jsonLD.name;
        if (!name) name = $("h1.product-name").first().text().trim();
        outputData.name = name;

        // aggregateRating
        const ratingData = { bestRating: null, ratingValue: null, reviewCount: null, worstRating: null };
        if (jsonLD && jsonLD.aggregateRating) {
            const ar = jsonLD.aggregateRating;
            if (ar.ratingValue) ratingData.ratingValue = parseFloat(ar.ratingValue);
            if (ar.reviewCount) ratingData.reviewCount = parseInt(ar.reviewCount);
        }
        if (ratingData.ratingValue === null) {
            const rv = $(".aggregate-rating [itemprop='ratingValue']").first().text().trim();
            if (rv) ratingData.ratingValue = parseFloat(rv);
            const rc = $(".aggregate-rating [itemprop='reviewCount']").first().text().trim();
            if (rc) ratingData.reviewCount = parseInt(rc);
        }
        outputData.aggregateRating = ratingData;

        // availability
        let availability = "out_of_stock";
        if (jsonLD && jsonLD.offers && jsonLD.offers.availability) {
            if (jsonLD.offers.availability.includes("InStock")) availability = "in_stock";
        }
        if ($("link[itemprop='availability']").attr("href")?.includes("InStock")) {
            availability = "in_stock";
        }
        outputData.availability = availability;

        // brand
        let brand = "";
        if (jsonLD && jsonLD.brand) brand = jsonLD.brand.name || "";
        if (!brand) brand = $(".product-brand .brand-link").first().text().trim();
        if (!brand) brand = $(".product-brand").first().text().trim();
        outputData.brand = brand;

        outputData.category = null;

        // currency
        let currency = "USD";
        if (jsonLD && jsonLD.offers && jsonLD.offers.priceCurrency) {
            currency = jsonLD.offers.priceCurrency;
        } else {
            currency = detectCurrency($(".product-purchase .currency, .price").text());
        }
        outputData.currency = currency;

        // description
        let description = "";
        if (jsonLD && jsonLD.description) description = jsonLD.description;
        if (!description) description = $(".product-details .description").html() || "";
        outputData.description = description;

        // features
        let features = [];
        if (jsonLD && jsonLD.description && jsonLD.description.includes("<ul")) {
            const inner$ = cheerio.load(jsonLD.description);
            inner$("li").each((i, el) => {
                const text = inner$(el).text().trim();
                if (text && !text.startsWith("Size:")) features.push(text);
            });
        }
        if (features.length === 0) {
            $("ul.features li, .product-features li, .key-features li").each((i, el) => {
                features.push($(el).text().trim());
            });
        }
        if (features.length === 0) {
            $("h5").each((i, el) => {
                const headerText = $(el).text().toLowerCase();
                if (headerText.includes("special") || headerText.includes("ingredients") || headerText.includes("features")) {
                    $(el).nextAll("ul").first().find("li").each((j, li) => {
                        features.push($(li).text().trim());
                    });
                }
            });
        }
        outputData.features = [...new Set(features.filter(f => f !== ""))];

        // images
        const images = [];
        const seenImages = new Set();
        $("[data-section='product-carousel'] img").each((i, el) => {
            let src = $(el).attr("src");
            const alt = $(el).attr("alt") || "";
            if (!src || src.includes("afterpay") || src.includes("sezzle") || src.includes("p_35x35")) return;
            if (src.includes("p_85x85.jpg")) src = src.replace("p_85x85.jpg", "zb_p.jpg");
            const abs = makeAbsoluteURL(src);
            if (!seenImages.has(abs)) {
                images.push({ url: abs, altText: alt });
                seenImages.add(abs);
            }
        });
        if (images.length === 0 && jsonLD && jsonLD.image) {
            const ldImgs = Array.isArray(jsonLD.image) ? jsonLD.image : [jsonLD.image];
            ldImgs.forEach(img => {
                const abs = makeAbsoluteURL(img);
                if (!seenImages.has(abs)) {
                    images.push({ url: abs, altText: name });
                    seenImages.add(abs);
                }
            });
        }
        outputData.images = images;

        outputData.preDiscountPrice = null;

        // price
        let price = 0;
        if (jsonLD && jsonLD.offers && jsonLD.offers.price) {
            price = parseFloat(jsonLD.offers.price);
        }
        if (!price) {
            const priceText = $(".price").attr("data-price") || $(".price").text();
            const match = priceText.replace(/,/g, "").match(/[\d,]+\.?\d*/);
            if (match) price = parseFloat(match[0]);
        }
        outputData.price = price;

        // productId
        let productId = "";
        const canonical = $("link[rel='canonical']").attr("href");
        if (canonical) {
            const parts = canonical.replace(/\/$/, "").split("/");
            productId = parts[parts.length - 1];
        }
        outputData.productId = productId;

        // reviews
        let reviews = [];
        if (jsonLD && jsonLD.review) {
            reviews = Array.isArray(jsonLD.review) ? jsonLD.review : [jsonLD.review];
        }
        if (reviews.length === 0) {
            $("[itemprop='review'], .review-item, [data-hook='review'], .reviews-section .review").each((i, el) => {
                const s = $(el);
                const review = {
                    author: s.find("[itemprop='author'], .review-author, .author").text().trim(),
                    date: s.find("[itemprop='datePublished'], .review-date").attr("content") || s.find(".review-date").text().trim(),
                    description: s.find("[itemprop='description'], .review-body, .review-text, .content").text().trim(),
                    title: s.find(".review-title, .review-heading, .title").text().trim(),
                };
                let rv = s.find("[itemprop='ratingValue']").attr("content") || s.find(".review-rating, .rating, .stars").text().trim();
                review.ratingValue = parseFloat(rv) || null;
                if (review.description || review.author) reviews.push(review);
            });
        }
        outputData.reviews = reviews;

        // seller
        const seller = { name: "Beautylish", rating: null, url: "https://www.beautylish.com" };
        const sName = $(".seller-info .seller-name").first().text().trim();
        if (sName) seller.name = sName;
        const sUrl = $(".seller-info .seller-name").attr("href");
        if (sUrl) seller.url = makeAbsoluteURL(sUrl);
        outputData.seller = seller;

        outputData.serialNumbers = [];

        // specifications
        const specs = [];
        $(".specifications .spec-item, .product-specs .spec-item").each((i, el) => {
            const s = $(el);
            let key = s.find(".key").first().text().trim().replace(/:$/, "");
            let val = s.find(".value").first().text().trim();
            if (!val && s.text().includes(":")) {
                const parts = s.text().split(":");
                val = parts[1].trim();
            }
            if (key && val) specs.push({ key, value: val });
        });
        if (specs.length === 0) {
            $("h5").each((i, el) => {
                if ($(el).text().toLowerCase().includes("other details")) {
                    $(el).nextAll("ul").first().find("li").each((j, li) => {
                        const text = $(li).text();
                        if (text.includes(":")) {
                            const [k, v] = text.split(":");
                            specs.push({ key: k.trim(), value: v.trim() });
                        } else if (text.trim()) {
                            const dietary = ["Gluten-Free", "Dairy-Free", "No Sugar Added", "Paleo Friendly", "Whole 30 Approved"];
                            const isDietary = dietary.some(kw => text.includes(kw));
                            specs.push({ key: isDietary ? "Dietary" : "Feature", value: text.trim() });
                        }
                    });
                }
            });
        }
        outputData.specifications = specs;
        outputData.url = makeAbsoluteURL(canonical);

        // videos
        const videos = [];
        const seenVids = new Set();
        const videoSelectors = ["iframe[data-type='video']", ".video-container iframe", ".product-media iframe"];
        videoSelectors.forEach(sel => {
            $(sel).each((i, el) => {
                const src = $(el).attr("src") || $(el).attr("data-src");
                if (src) {
                    const abs = makeAbsoluteURL(src.trim());
                    if (!abs.toLowerCase().includes("attn.tv") && !seenVids.has(abs)) {
                        videos.push({ url: abs });
                        seenVids.add(abs);
                    }
                }
            });
        });
        if (videos.length === 0) {
            $("main a[href*='youtube.com'], main a[href*='youtu.be'], main a[href*='vimeo.com']").each((i, el) => {
                const href = $(el).attr("href");
                if (href) {
                    const abs = makeAbsoluteURL(href.trim());
                    if (!seenVids.has(abs)) {
                        videos.push({ url: abs });
                        seenVids.add(abs);
                    }
                }
            });
        }
        outputData.videos = videos;

        return outputData;
    } catch (error) {
        console.error('Error extracting data from', url, ':', error);
        return null;
    }
}

/**
 * Scrape a single page with retry logic using Playwright with stealth
 * @param {string} url - URL to scrape
 * @param {DataPipeline} pipeline - Data pipeline instance
 * @param {Object} browser - Playwright browser instance
 * @param {number} retries - Number of retries
 */
async function scrapePage(url, pipeline, browser, retries = CONFIG.maxRetries) {
    let success = false;
    let attempts = 0;

    while (attempts <= retries && !success) {
        let context = null;
        let page = null;
        
        try {
            // Create context with optimizations
            context = await browser.newContext({
                ignoreHTTPSErrors: true,
                viewport: { width: 1920, height: 1080 },
                userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36'
            });
            
            page = await context.newPage();
            
            // Block unnecessary resources for performance optimization
            await page.route('**/*', (route) => {
                const resourceType = route.request().resourceType();
                if (['image', 'media', 'font', 'stylesheet'].includes(resourceType)) {
                    route.abort();
                } else {
                    route.continue();
                }
            });
            
            // Navigate with optimized wait strategy
            await page.goto(url, { 
                waitUntil: 'domcontentloaded',
                timeout: CONFIG.timeout 
            });
            
            // Wait a bit for dynamic content to load
            await page.waitForTimeout(2000);
            
            const bodyHTML = await page.evaluate(() => document.body.innerHTML);
            const $ = cheerio.load(bodyHTML);
            
            const scrapedData = extractData($, url);
            
            if (scrapedData) {
                await pipeline.addData(scrapedData);
                success = true;
                console.log('Successfully scraped:', url);
            } else {
                console.warn('No data extracted from:', url);
            }
        } catch (error) {
            console.error('Exception scraping', url, ':', error.message);
            
            if (attempts < retries) {
                const delay = Math.pow(2, attempts) * 1000;
                console.log('Retrying in', delay, 'ms...');
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        } finally {
            if (page) await page.close();
            if (context) await context.close();
            attempts++;
        }
    }

    if (!success) {
        console.error('Failed to scrape', url, 'after', retries, 'retries');
    }
}

/**
 * Scrape multiple URLs concurrently with controlled concurrency
 * @param {string[]} urls - Array of URLs to scrape
 */
async function concurrentScraping(urls) {
    const pipeline = new DataPipeline(CONFIG.outputFile);
    
    // Launch browser with performance optimizations
    const browser = await chromium.launch({
        headless: true,
        proxy: PROXY_CONFIG,
        args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-accelerated-2d-canvas',
            '--no-first-run',
            '--no-zygote',
            '--disable-gpu',
            '--disable-web-security'
        ]
    });

    try {
        // Process URLs in batches to control concurrency
        for (let i = 0; i < urls.length; i += CONFIG.maxConcurrency) {
            const batch = urls.slice(i, i + CONFIG.maxConcurrency);
            const promises = batch.map(url => scrapePage(url, pipeline, browser, CONFIG.maxRetries));
            
            try {
                await Promise.all(promises);
                console.log('Completed batch', Math.floor(i / CONFIG.maxConcurrency) + 1, 'of', Math.ceil(urls.length / CONFIG.maxConcurrency));
            } catch (error) {
                console.error('Error in batch processing:', error);
            }
        }
    } finally {
        await browser.close();
    }
}

/**
 * Main execution function
 */
async function main() {
    const urls = [
        'https://www.beautylish.com/s/vital-proteins-vanilla-collagen-creamer-10-6-oz',
    ];

    console.log('Starting concurrent scraping with NodeJS Playwright-Extra + Stealth...');
    console.log('URLs to scrape:', urls.length);
    console.log('Max concurrency:', CONFIG.maxConcurrency);
    console.log('Output file:', CONFIG.outputFile);

    try {
        await concurrentScraping(urls);
        console.log('Scraping completed successfully!');
    } catch (error) {
        console.error('Scraping failed:', error);
        process.exit(1);
    }
}

// Run the scraper if this file is executed directly
if (require.main === module) {
    main().catch(console.error);
}

module.exports = { extractData, scrapePage, concurrentScraping, DataPipeline };