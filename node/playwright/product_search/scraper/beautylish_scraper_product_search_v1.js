/**
 * Generated by: ScrapeOps AI Scraper Generator on 2026-02-16
 * Signup For Free Beta: https://scrapeops.io/app/register/ai-scraper-generator
 * Docs & Updates: https://scrapeops.io/docs/ai-scraper-generator
 * For Support & Feedback Email: ai-scraper-generator@scrapeops.io
 */

const { chromium } = require('playwright-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
const cheerio = require('cheerio');
const fs = require('fs');
const { promisify } = require('util');

// Add stealth plugin
chromium.use(StealthPlugin());

const API_KEY = 'YOUR-API_KEY';

/**
 * Generate output filename with current timestamp
 * @returns {string} Output filename
 */
function generateOutputFilename() {
    const now = new Date();
    const timestamp = now.getFullYear().toString() +
        (now.getMonth() + 1).toString().padStart(2, '0') +
        now.getDate().toString().padStart(2, '0') + '_' +
        now.getHours().toString().padStart(2, '0') +
        now.getMinutes().toString().padStart(2, '0') +
        now.getSeconds().toString().padStart(2, '0');
    return 'beautylish_com_product_search_page_scraper_data_' + timestamp + '.jsonl';
}

// ScrapeOps Residential Proxy Configuration
const PROXY_CONFIG = {
    server: 'http://residential-proxy.scrapeops.io:8181',
    username: 'scrapeops',
    password: API_KEY
};

// Configuration
const CONFIG = {
    maxRetries: 3,
    maxConcurrency: 1,
    timeout: 180000,
    outputFile: generateOutputFilename()
};

/**
 * Data pipeline for handling scraped data
 */
class DataPipeline {
    constructor(outputFile = CONFIG.outputFile) {
        this.itemsSeen = new Set();
        this.outputFile = outputFile;
        this.writeFile = promisify(fs.appendFile);
    }

    isDuplicate(data) {
        const itemKey = JSON.stringify(data);
        if (this.itemsSeen.has(itemKey)) {
            console.warn('Duplicate item found, skipping');
            return true;
        }
        this.itemsSeen.add(itemKey);
        return false;
    }

    async addData(scrapedData) {
        if (!this.isDuplicate(scrapedData)) {
            try {
                const jsonLine = JSON.stringify(scrapedData) + '\n';
                await this.writeFile(this.outputFile, jsonLine, 'utf8');
                console.log('Saved item to', this.outputFile);
            } catch (error) {
                console.error('Error saving data:', error);
            }
        }
    }
}

/**
 * Utility to make URLs absolute
 * @param {string} urlStr 
 * @returns {string}
 */
function makeAbsoluteURL(urlStr) {
    if (!urlStr) return "";
    if (urlStr.startsWith("http://") || urlStr.startsWith("https://")) return urlStr;
    if (urlStr.startsWith("//")) return "https:" + urlStr;
    const domain = "https://www.beautylish.com";
    if (urlStr.startsWith("/")) return domain + urlStr;
    return domain + "/" + urlStr;
}

/**
 * Detect currency from price string
 * @param {string} priceText 
 * @returns {string}
 */
function detectCurrency(priceText) {
    if (!priceText) return "USD";
    const text = priceText.toUpperCase();
    const currencyMap = {
        "USD": "USD", "US$": "USD", "US $": "USD", "$": "USD",
        "EUR": "EUR", "€": "EUR",
        "GBP": "GBP", "£": "GBP", "GB£": "GBP",
        "JPY": "JPY", "¥": "JPY", "JP¥": "JPY",
        "CAD": "CAD", "CA$": "CAD", "C$": "CAD",
        "AUD": "AUD", "AU$": "AUD", "A$": "AUD",
        "CNY": "CNY", "CN¥": "CNY", "RMB": "CNY",
        "CHF": "CHF", "FR.": "CHF",
        "SEK": "SEK", "KR": "SEK",
        "NZD": "NZD", "NZ$": "NZD",
    };
    for (const [code, currency] of Object.entries(currencyMap)) {
        if (text.includes(code)) return currency;
    }
    return "USD";
}

/**
 * Extract numeric value from price string
 * @param {string} priceText 
 * @returns {number}
 */
function extractNumericPrice(priceText) {
    if (!priceText) return 0.0;
    const cleanStr = priceText.replace(/,/g, '');
    const match = cleanStr.match(/([\d,]+\.?\d*)/);
    if (match) {
        return parseFloat(match[1]) || 0.0;
    }
    return 0.0;
}

/**
 * Extract structured data from HTML using Cheerio
 * @param {Object} $ - Cheerio instance
 * @param {string} url - Source URL
 * @returns {Object|null} - Extracted data or null
 */
function extractData($, url) {
    try {
        const products = [];

        // Strategy 1: DOM Scraping
        const productSelectors = ".product-item, [data-item-type='product'], .product-grid-item, .item-grid__item, [data-product-id], .recommendation-card, .product-card";
        $(productSelectors).each((i, el) => {
            const s = $(el);
            const p = {};

            let name = s.find(".product-name, .item-title, .item-grid__name, h3, .name, .product-card__name").first().text().trim();
            if (!name) {
                name = s.find("a").first().text().trim();
            }
            p.name = name;

            const priceStr = s.find(".price, .product-price, .item-price, .item-grid__price, .product-card__price").first().text();
            p.price = extractNumericPrice(priceStr);

            p.aggregateRating = {
                bestRating: 5.0,
                ratingValue: 0.0,
                reviewCount: 0,
                worstRating: 1.0,
            };
            p.availability = "in_stock";

            const brand = s.find(".brand-name, .product-brand, .item-grid__brand, .product-card__brand").first().text().trim();
            p.brand = brand;
            p.category = "";
            p.currency = detectCurrency(priceStr);
            p.description = "";
            p.features = [];

            const images = [];
            const img = s.find("img").first();
            let imgSrc = img.attr("src") || img.attr("data-src") || img.attr("data-lazy-src") || "";

            if (imgSrc) {
                images.push({
                    altText: name,
                    url: makeAbsoluteURL(imgSrc),
                });
            }
            p.images = images;
            p.preDiscountPrice = null;
            p.productId = s.attr("data-product-id") || "";
            p.reviews = [];
            p.seller = {
                name: "Beautylish",
                rating: 0.0,
                url: "https://www.beautylish.com",
            };
            p.serialNumbers = [];
            p.specifications = [];

            const prodUrl = s.find("a").first().attr("href") || "";
            p.url = makeAbsoluteURL(prodUrl);
            p.videos = [];

            if (p.name) {
                products.push(p);
            }
        });

        // Strategy 2: JSON Fallback (__NEXT_DATA__)
        if (products.length === 0) {
            const nextDataText = $("script#__NEXT_DATA__").text();
            if (nextDataText) {
                try {
                    const jsonData = JSON.parse(nextDataText);
                    let rawProds = [];

                    const pageProps = jsonData?.props?.pageProps;
                    if (pageProps) {
                        if (Array.isArray(pageProps.products)) {
                            rawProds = pageProps.products;
                        } else if (Array.isArray(pageProps.results)) {
                            rawProds = pageProps.results;
                        } else if (Array.isArray(pageProps.searchData?.items)) {
                            rawProds = pageProps.searchData.items;
                        }
                    }

                    for (const item of rawProds) {
                        const p = {};
                        p.name = item.product_name || item.name || "";
                        
                        if (typeof item.price === 'number') {
                            p.price = item.price;
                        } else if (item.price_string) {
                            p.price = extractNumericPrice(item.price_string);
                        } else {
                            p.price = 0.0;
                        }

                        p.brand = item.brand_name || "";
                        p.productId = item.id ? String(item.id) : "";
                        
                        if (item.slug) {
                            p.url = makeAbsoluteURL("/s/" + item.slug);
                        } else if (item.url) {
                            p.url = makeAbsoluteURL(item.url);
                        } else {
                            p.url = "";
                        }

                        p.availability = "in_stock";
                        p.currency = "USD";
                        p.images = [];
                        if (item.image_url) {
                            p.images.push({
                                url: makeAbsoluteURL(item.image_url),
                                altText: p.name
                            });
                        }

                        p.seller = { name: "Beautylish", url: "https://www.beautylish.com" };
                        p.aggregateRating = { bestRating: 5.0, ratingValue: 0.0, reviewCount: 0, worstRating: 1.0 };
                        p.reviews = [];
                        p.serialNumbers = [];
                        p.specifications = [];
                        p.videos = [];

                        if (p.name) {
                            products.push(p);
                        }
                    }
                } catch (e) {
                    console.error("Error parsing __NEXT_DATA__ JSON", e);
                }
            }
        }

        const queryAttr = $("input[name='q']").attr("value") || "";
        const searchMeta = {
            query: queryAttr,
            resultsDisplayed: products.length,
            searchType: "keyword",
            searchUrl: "https://www.beautylish.com/shop/browse?q=" + encodeURIComponent(queryAttr),
            totalResults: products.length
        };

        return {
            breadcrumbs: null,
            pagination: null,
            products: products,
            recommendations: null,
            relatedSearches: null,
            searchMetadata: searchMeta,
            sponsoredProducts: null,
            url: url,
            timestamp: new Date().toISOString()
        };
    } catch (error) {
        console.error('Error extracting data from', url, ':', error);
        return null;
    }
}

/**
 * Scrape a single page with retry logic using Playwright with stealth
 * @param {string} url - URL to scrape
 * @param {DataPipeline} pipeline - Data pipeline instance
 * @param {Object} browser - Playwright browser instance
 * @param {number} retries - Number of retries
 */
async function scrapePage(url, pipeline, browser, retries = CONFIG.maxRetries) {
    let success = false;
    let attempts = 0;

    while (attempts <= retries && !success) {
        let context = null;
        let page = null;
        
        try {
            context = await browser.newContext({
                ignoreHTTPSErrors: true,
                viewport: { width: 1920, height: 1080 },
                userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36'
            });
            
            page = await context.newPage();
            
            await page.route('**/*', (route) => {
                const resourceType = route.request().resourceType();
                if (['image', 'media', 'font', 'stylesheet'].includes(resourceType)) {
                    route.abort();
                } else {
                    route.continue();
                }
            });
            
            await page.goto(url, { 
                waitUntil: 'domcontentloaded',
                timeout: CONFIG.timeout 
            });
            
            await page.waitForTimeout(2000); // Standard wait for dynamic components
            
            const bodyHTML = await page.evaluate(() => document.body.innerHTML);
            const $ = cheerio.load(bodyHTML);
            
            const scrapedData = extractData($, url);
            
            if (scrapedData && scrapedData.products && scrapedData.products.length > 0) {
                await pipeline.addData(scrapedData);
                success = true;
                console.log('Successfully scraped:', url, `Found ${scrapedData.products.length} products`);
            } else if (scrapedData) {
                // If it extracted successfully but found 0 products, still consider it a pass if meta exists
                await pipeline.addData(scrapedData);
                success = true;
                console.warn('Scraped page but found 0 products:', url);
            } else {
                console.warn('No data extracted from:', url);
            }
        } catch (error) {
            console.error('Exception scraping', url, ':', error.message);
            
            if (attempts < retries) {
                const delay = Math.pow(2, attempts) * 1000;
                console.log('Retrying in', delay, 'ms...');
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        } finally {
            if (page) await page.close();
            if (context) await context.close();
            attempts++;
        }
    }

    if (!success) {
        console.error('Failed to scrape', url, 'after', retries, 'retries');
    }
}

/**
 * Scrape multiple URLs concurrently with controlled concurrency
 * @param {string[]} urls - Array of URLs to scrape
 */
async function concurrentScraping(urls) {
    const pipeline = new DataPipeline(CONFIG.outputFile);
    
    const browser = await chromium.launch({
        headless: true,
        proxy: PROXY_CONFIG,
        args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-accelerated-2d-canvas',
            '--no-first-run',
            '--no-zygote',
            '--disable-gpu',
            '--disable-web-security'
        ]
    });

    try {
        for (let i = 0; i < urls.length; i += CONFIG.maxConcurrency) {
            const batch = urls.slice(i, i + CONFIG.maxConcurrency);
            const promises = batch.map(url => scrapePage(url, pipeline, browser, CONFIG.maxRetries));
            
            try {
                await Promise.all(promises);
                console.log('Completed batch', Math.floor(i / CONFIG.maxConcurrency) + 1, 'of', Math.ceil(urls.length / CONFIG.maxConcurrency));
            } catch (error) {
                console.error('Error in batch processing:', error);
            }
        }
    } finally {
        await browser.close();
    }
}

/**
 * Main execution function
 */
async function main() {
    const urls = [
        'https://www.beautylish.com/shop/browse?utm_source=internal_search&utm_campaign=Search+Beautylish+Products&q=hair+shampoo',
    ];

    console.log('Starting concurrent scraping with NodeJS Playwright-Extra + Stealth...');
    console.log('URLs to scrape:', urls.length);
    console.log('Max concurrency:', CONFIG.maxConcurrency);
    console.log('Output file:', CONFIG.outputFile);

    try {
        await concurrentScraping(urls);
        console.log('Scraping completed successfully!');
    } catch (error) {
        console.error('Scraping failed:', error);
        process.exit(1);
    }
}

// Run the scraper if this file is executed directly
if (require.main === module) {
    main().catch(console.error);
}

module.exports = { extractData, scrapePage, concurrentScraping, DataPipeline };